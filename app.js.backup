// ---------------------------
// Vibe Data for Swiping
// ---------------------------

const vibes = [
    { 
        name: "Cozy Night In", 
        emoji: "üõãÔ∏è",
        description: "Comfort food, warm blankets, Netflix marathon",
        prompt: "comforting, hearty, perfect for staying in on a cold night",
        color: "#8B7355",
        image: "images/cozy_night.jpg"
    },
    { 
        name: "Healthy & Fresh", 
        emoji: "ü•ó",
        description: "Light, nutritious, energizing",
        prompt: "healthy, fresh, light but satisfying, packed with vegetables",
        color: "#7CB342",
        image: "images/healthy_fresh.jpg"
    },
    { 
        name: "Spicy Adventure", 
        emoji: "üå∂Ô∏è",
        description: "Bold flavors, exotic ingredients, heat",
        prompt: "spicy, adventurous, bold flavors, exciting and intense",
        color: "#D32F2F",
        image: "images/spicy_adventure.jpg"
    },
    { 
        name: "Quick & Easy", 
        emoji: "‚ö°",
        description: "Minimal effort, maximum flavor, under 30 mins",
        prompt: "quick, easy, minimal cleanup, perfect for busy weeknights",
        color: "#1976D2",
        image: "images/quick_easy.jpg"
    },
    { 
        name: "Romantic Dinner", 
        emoji: "üïØÔ∏è",
        description: "Elegant, impressive, date night worthy",
        prompt: "romantic, elegant, impressive but not too complicated",
        color: "#E91E63",
        image: "images/romantic_dinner.jpg"
    },
    { 
        name: "Hangover Cure", 
        emoji: "ü§ï",
        description: "Soothing, greasy, restorative",
        prompt: "comforting, greasy, perfect for curing a hangover",
        color: "#FF6F00",
        image: "images/hangover_cure.jpg"
    },
    { 
        name: "Summer Vibes", 
        emoji: "‚òÄÔ∏è",
        description: "Grilling, fresh, light, outdoor friendly",
        prompt: "fresh, summery, perfect for grilling or outdoor dining",
        color: "#FFB300",
        image: "images/summer_vibes.jpg"
    },
    { 
        name: "Comfort Food Classic", 
        emoji: "üç≤",
        description: "Nostalgic, hearty, like mom used to make",
        prompt: "classic comfort food, nostalgic, hearty and satisfying",
        color: "#6D4C41",
        image: "images/comfort_food.jpg"
    }
];

let vibeProfile = [];
const maxVibeRounds = 5;
let currentVibeRound = 0;
let ingredientsAtHome = ''; // Only initialize once here

const container = document.getElementById("card-container");
const resultEl = document.getElementById("result");

// Create global glow overlays once
const likeGlow = document.createElement("div");
likeGlow.classList.add("swipe-glow", "like-glow");
likeGlow.innerHTML = '<div class="glow-icon">‚úì</div>';
document.body.appendChild(likeGlow);

const nopeGlow = document.createElement("div");
nopeGlow.classList.add("swipe-glow", "nope-glow");
nopeGlow.innerHTML = '<div class="glow-icon">‚úó</div>';
document.body.appendChild(nopeGlow);

// ---------------------------
// Create Vibe Card for Swipe Deck
// ---------------------------

function createCard(vibe) {
    const card = document.createElement("div");
    card.classList.add("card", "vibe-card");
    card.style.backgroundImage = `url('${vibe.image}')`;
    card.style.backgroundSize = "cover";
    card.style.backgroundPosition = "center";
    card.style.border = `2px solid ${vibe.color}50`;
    card.style.top = `${currentVibeRound * 5}px`;

    const overlay = document.createElement("div");
    overlay.classList.add("overlay", "vibe-overlay");
    overlay.style.background = `linear-gradient(to bottom, rgba(0,0,0,0.3), rgba(0,0,0,0.7))`;
    overlay.innerHTML = `
        <div class="vibe-emoji">${vibe.emoji}</div>
        <div class="vibe-name">${vibe.name}</div>
        <div class="vibe-description">${vibe.description}</div>
    `;
    card.appendChild(overlay);

    return card;
}

// ---------------------------
// Shuffle helper
// ---------------------------

function shuffle(array) {
    return array.sort(() => 0.5 - Math.random());
}

// ---------------------------
// Drag & Swipe
// ---------------------------

function initSwipe(card, vibe) {
    let isDragging = false;
    let startX = 0;
    let currentX = 0;

    // Mouse events
    card.addEventListener("mousedown", e => {
        isDragging = true;
        startX = e.clientX;
        card.style.transition = "none";
    });

    // Touch events for mobile
    card.addEventListener("touchstart", e => {
        isDragging = true;
        startX = e.touches[0].clientX;
        card.style.transition = "none";
    }, { passive: true });

    document.addEventListener("mousemove", e => {
        if (!isDragging) return;
        currentX = e.clientX - startX;
        updateCardPosition(card, currentX);
    });

    document.addEventListener("touchmove", e => {
        if (!isDragging) return;
        currentX = e.touches[0].clientX - startX;
        updateCardPosition(card, currentX);
    }, { passive: true });

    document.addEventListener("mouseup", () => {
        handleSwipeEnd(card, vibe);
    });

    document.addEventListener("touchend", () => {
        handleSwipeEnd(card, vibe);
    });
}

function updateCardPosition(card, currentX) {
    card.style.transform = `translateX(${currentX}px) rotate(${currentX * 0.05}deg)`;

    // Progressive glow based on swipe distance
    const maxDistance = 200;
    const likeIntensity = Math.max(0, Math.min(1, currentX / maxDistance));
    const nopeIntensity = Math.max(0, Math.min(1, -currentX / maxDistance));

    likeGlow.style.opacity = likeIntensity * 0.6;
    nopeGlow.style.opacity = nopeIntensity * 0.6;
}

function handleSwipeEnd(card, vibe) {
    if (!isDragging) return;
    isDragging = false;
    card.style.transition = "transform 0.3s ease";

    if (currentX > 120) {
        // User likes this vibe - add to profile
        vibeProfile.push(vibe);
        animateOff(card, 500);
    } else if (currentX < -120) {
        // User rejects this vibe - don't add to profile
        animateOff(card, -500);
    } else {
        card.style.transform = "translateX(0px) rotate(0deg)";
    }
    
    // Reset glows
    likeGlow.style.opacity = 0;
    nopeGlow.style.opacity = 0;
    currentX = 0;
}

function animateOff(card, distance) {
    card.style.transform = `translateX(${distance}px) rotate(${distance * 0.05}deg)`;
    setTimeout(() => {
        card.remove();
        showNextCard();
    }, 300);
}

// ---------------------------
// Deck Logic
// ---------------------------

function showNextCard() {
    if (currentVibeRound >= maxVibeRounds) {
        showResult();
        return;
    }

    currentVibeRound++;
    const vibe = shuffle(vibes)[0];
    const card = createCard(vibe);
    container.appendChild(card);
    initSwipe(card, vibe);
}

// ---------------------------
// Generate Personalized Prompt Based on Vibe Profile
// ---------------------------

function generatePersonalizedPrompt() {
    console.log("generatePersonalizedPrompt called. ingredientsAtHome:", JSON.stringify(ingredientsAtHome));
    if (vibeProfile.length === 0) {
        return "Write me a delicious recipe that would be perfect for any occasion.";
    }

    // Combine all the vibe prompts into a cohesive description
    const vibeDescriptions = vibeProfile.map(vibe => vibe.prompt);
    const combinedVibes = vibeDescriptions.join(", ");
    
    let prompt = `Can you make a recipe for someone that has this vibe:

${combinedVibes}

Please write me a clear, well-formatted recipe that matches these preferences. `;
    
    if (ingredientsAtHome) {
        prompt += `Try to incorporate these ingredients they already have: ${ingredientsAtHome}. `;
    }
    
    prompt += `Structure it exactly like this (follow the formatting rules strictly):

Recipe Name
===

Ingredients:
‚Ä¢ [ingredient 1]
‚Ä¢ [ingredient 2]
‚Ä¢ [ingredient 3]

Instructions:
1. [step 1]
2. [step 2]
3. [step 3]

Formatting rules:
- Use the exact header text "Ingredients:" on its own line.
- Use the exact header text "Instructions:" on its own line.
- Put each ingredient on its own line (prefer starting with "‚Ä¢ ").
- Put each instruction on its own line starting with "1.", "2.", etc.
- Do not merge ingredients and instructions into the same paragraph.
- Do not omit the Instructions header.

Keep it concise but complete.`;

    return prompt;
}

async function fetchLocalRecipe(prompt) {
    console.log("fetchLocalRecipe called with:", prompt);
    
    try {
        const res = await fetch('/api/generateRecipe', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt })
        });
        
        console.log("Response status:", res.status);
        
        if (!res.ok) {
            throw new Error(`HTTP error! status: ${res.status}`);
        }
        
        const data = await res.json();
        console.log("Response data:", data);
        
        if (data.error) {
            throw new Error(data.error);
        }
        
        return data.recipe;
    } catch (error) {
        console.error("Error in fetchLocalRecipe:", error);
        throw error;
    }
}
async function showResult() {
    // Hide swipe deck & title
    container.style.display = "none";
    document.querySelector("h1").style.display = "none";

    // Clear and show result container
    resultEl.innerHTML = ""; // clear static content
    resultEl.style.display = "flex";
    resultEl.style.flexDirection = "column";
    resultEl.style.justifyContent = "center";
    resultEl.style.alignItems = "center";
    resultEl.style.height = "100vh";
    resultEl.style.margin = 0;

    // Create personalized prompt based on user's vibe profile
    const personalizedPrompt = generatePersonalizedPrompt();
    console.log("Generated personalized prompt:", personalizedPrompt);

    // Sparkle container (behind card)
    const sparkleContainer = document.createElement("div");
    sparkleContainer.id = "sparkle-container";
    resultEl.appendChild(sparkleContainer);

    // Flip card wrapper
    const wrapper = document.createElement("div");
    wrapper.classList.add("recipe-card-wrapper");

    // Front (vibe summary)
    const front = document.createElement("div");
    front.classList.add("card-face", "front");
    
    // Create vibe summary content
    const vibeSummary = vibeProfile.length > 0 
        ? `<div class="vibe-summary">
            <h2>üéØ Your Vibe Profile</h2>
            <div class="selected-vibes">
                ${vibeProfile.map(vibe => `<span class="vibe-tag">${vibe.emoji} ${vibe.name}</span>`).join('')}
            </div>
            <p class="vibe-description">Ready for your personalized recipe?</p>
           </div>`
        : `<div class="vibe-summary">
            <h2>üç≥ Ready to Cook!</h2>
            <p>Let's find you a delicious recipe!</p>
           </div>`;
    
    front.innerHTML = vibeSummary;

    // Back (ingredients at home input)
    const back = document.createElement("div");
    back.classList.add("card-face", "back");
    back.innerHTML = `
        <h2>What do you have at home?</h2>
        <p class="ingredients-subtitle">Optional: List ingredients you'd like to use (e.g., chicken, rice, tomatoes)</p>
        <textarea class="ingredients-input" placeholder="e.g., chicken breast, rice, garlic, spinach..." rows="3"></textarea>
        <div class="ingredients-buttons">
            <button class="add-ingredients-btn">‚ûï Add Ingredients</button>
            <button class="generate-btn">üç≥ Generate My Recipe</button>
        </div>
        <div class="ingredients-confirmation"></div>
    `;

    // Add event listeners
    const generateBtn = back.querySelector('.generate-btn');
    const addBtn = back.querySelector('.add-ingredients-btn');
    const ingredientsInput = back.querySelector('.ingredients-input');
    const confirmation = back.querySelector('.ingredients-confirmation');

    addBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const rawValue = ingredientsInput.value.trim();
        console.log("Add clicked. rawValue:", JSON.stringify(rawValue));
        console.log("Current ingredientsAtHome before:", JSON.stringify(ingredientsAtHome));
        if (rawValue) {
            // Split new ingredients by commas, clean each, and filter empty
            const newItems = rawValue.split(',')
                .map(item => item.trim().toLowerCase())
                .filter(item => item.length > 0);
            
            // Split existing ingredients (if any) and dedupe
            const existingItems = ingredientsAtHome
                ? ingredientsAtHome.split(',').map(item => item.trim().toLowerCase())
                : [];
            
            // Combine and dedupe
            const combined = [...existingItems, ...newItems];
            const uniqueItems = [...new Set(combined)];
            
            // Update ingredientsAtHome with cleaned, unique list
            ingredientsAtHome = uniqueItems.join(', ');
            
            // Clear the textarea for next entry
            ingredientsInput.value = '';
            
            // Show confirmation
            confirmation.textContent = `‚úÖ Added: ${newItems.join(', ')}`;
            confirmation.style.color = '#6a4e42';
            console.log("newItems:", newItems);
            console.log("existingItems:", existingItems);
            console.log("uniqueItems:", uniqueItems);
            console.log("Ingredients saved after:", JSON.stringify(ingredientsAtHome));
        } else {
            confirmation.textContent = '‚ö†Ô∏è Please enter ingredients first';
            confirmation.style.color = '#c9a66b';
        }
    });

    generateBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent card flip
        console.log("Generating with ingredientsAtHome:", JSON.stringify(ingredientsAtHome));
        generatePersonalizedRecipe(personalizedPrompt, ingredientsAtHome);
    });

    // Prevent flip when clicking/focusing the textarea
    ingredientsInput.addEventListener('click', (e) => {
        e.stopPropagation();
    });

    ingredientsInput.addEventListener('focus', (e) => {
        e.stopPropagation();
    });

    wrapper.appendChild(front);
    wrapper.appendChild(back);
    resultEl.appendChild(wrapper);

    // Click to flip
    wrapper.addEventListener("click", () => wrapper.classList.toggle("flipped"));

    // Add sparkles around card
    setTimeout(() => {
        const rect = wrapper.getBoundingClientRect();
        const containerRect = resultEl.getBoundingClientRect();
        const centerX = rect.left - containerRect.left + rect.width / 2;
        const centerY = rect.top - containerRect.top + rect.height / 2;

        for (let i = 0; i < 40; i++) {
            const sparkle = document.createElement("div");
            sparkle.classList.add("sparkle");

            const size = 4 + Math.random() * 16;
            const angle = Math.random() * Math.PI * 2;
            const radius = 80 + Math.random() * 180;

            const x = centerX + radius * Math.cos(angle) - size/2;
            const y = centerY + radius * Math.sin(angle) - size/2;

            sparkle.style.left = `${x}px`;
            sparkle.style.top = `${y}px`;
            sparkle.style.width = `${size}px`;
            sparkle.style.height = `${size}px`;
            sparkle.style.transform = `rotate(${Math.random() * 360}deg)`;
            sparkle.style.animationDelay = `${Math.random() * 2}s`;
            sparkle.style.animationDuration = `${1.5 + Math.random() * 1.5}s`;

            sparkleContainer.appendChild(sparkle);
        }
    }, 100);
}

// Function to format recipe text with better HTML structure
function formatRecipeText(recipeText) {
    const applyInlineFormatting = (text) => {
        if (typeof text !== 'string') return text;
        return text
            .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
    };

    const introLines = [];
    const ingredientLines = [];
    const instructionLines = [];

    let mode = 'intro';
    const lines = String(recipeText || '').split('\n');
    for (const rawLine of lines) {
        const line = rawLine.trim();
        if (!line) continue;

        if (line.toLowerCase() === 'ingredients:' || line.toLowerCase().startsWith('ingredients:')) {
            mode = 'ingredients';
            continue;
        }
        if (line.toLowerCase() === 'instructions:' || line.toLowerCase().startsWith('instructions:')) {
            mode = 'instructions';
            continue;
        }

        if (line === '===') continue;

        if (mode === 'ingredients' && /^\d+(\.|\))\s+/.test(line)) {
            mode = 'instructions';
        }

        if (mode === 'ingredients') {
            ingredientLines.push(line);
        } else if (mode === 'instructions') {
            instructionLines.push(line);
        } else {
            introLines.push(line);
        }
    }

    const hasIngredients = ingredientLines.length > 0;
    const hasInstructions = instructionLines.length > 0;

    let html = '';

    if (introLines.length) {
        html += `<div class="recipe-intro">${applyInlineFormatting(introLines.join('\n'))}</div>`;
    }

    if (hasIngredients) {
        html += `
            <div class="recipe-section recipe-section-ingredients" data-recipe-section="ingredients">
                <h3>ü•ò Ingredients</h3>
                <ul class="ingredients-list">
                    ${ingredientLines
                        .map(item => item.replace(/^[-‚Ä¢]\s*/, ''))
                        .map(item => `<li>${applyInlineFormatting(item)}</li>`)
                        .join('')}
                </ul>
            </div>
        `;
    }

    if (hasInstructions) {
        html += `
            <div class="recipe-section recipe-section-instructions" data-recipe-section="instructions">
                <h3>üë®‚Äçüç≥ Instructions</h3>
                <ol class="instructions-list">
                    ${instructionLines
                        .map(item => item.replace(/^\d+\.|^\d+\)|^[-‚Ä¢]\s*/g, '').trim())
                        .map(item => `<li>${applyInlineFormatting(item)}</li>`)
                        .join('')}
                </ol>
            </div>
        `;
    }

    if (!html) {
        return {
            html: `<p>${applyInlineFormatting(String(recipeText || ''))}</p>`,
            hasIngredients: false,
            hasInstructions: false
        };
    }

    return { html, hasIngredients, hasInstructions };
}

// Global function to generate personalized recipe
async function generatePersonalizedRecipe(basePrompt, ingredients) {
    console.log("generatePersonalizedRecipe called with basePrompt:", basePrompt);
    console.log("generatePersonalizedRecipe called with ingredients:", JSON.stringify(ingredients));
    
    const back = document.querySelector('.card-face.back');
    const button = back.querySelector('.generate-btn');
    
    if (!back || !button) {
        console.error("Could not find back or button");
        return;
    }
    
    // Build the final prompt including ingredients if provided
    let finalPrompt = basePrompt;
    if (ingredients && ingredients.trim()) {
        finalPrompt = basePrompt.replace(
            "Please write me a clear, well-formatted recipe that matches these preferences. ",
            `Please write me a clear, well-formatted recipe that matches these preferences. Try to incorporate these ingredients they already have: ${ingredients.trim()}. `
        );
    }
    
    console.log("Final prompt to Ollama:", finalPrompt);
    
    // Show loading state with spinner
    button.innerHTML = '<span class="loading-spinner"></span> Generating... (this may take 30+ seconds)';
    button.disabled = true;
    
    try {
        console.log("Sending final prompt:", finalPrompt);
        
        // Add timeout to handle slow Ollama responses
        const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Request timeout - Ollama is taking too long')), 60000)
        );
        
        const recipeText = await Promise.race([
            fetchLocalRecipe(finalPrompt),
            timeoutPromise
        ]);
        
        console.log("Got personalized recipe text successfully");

        // Format the recipe text with better HTML structure
        const formattedRecipe = formatRecipeText(recipeText);
        const recipeHtml = typeof formattedRecipe === 'string' ? formattedRecipe : formattedRecipe.html;
        const hasIngredients = typeof formattedRecipe === 'string' ? false : formattedRecipe.hasIngredients;
        const hasInstructions = typeof formattedRecipe === 'string' ? false : formattedRecipe.hasInstructions;

        const showToggle = hasIngredients && hasInstructions;

        // Update the back content with generated recipe
        back.innerHTML = `
            <h2>Your Personalized Recipe</h2>
            ${showToggle ? `
                <div class="recipe-toggle" role="tablist" aria-label="Recipe sections">
                    <button type="button" class="recipe-toggle-btn active" data-target="ingredients">Ingredients</button>
                    <button type="button" class="recipe-toggle-btn" data-target="instructions">Instructions</button>
                </div>
            ` : ``}
            <div class="recipe-content">${recipeHtml}</div>
            <button class="reset-btn" onclick="location.reload()">üîÑ Start Over</button>
        `;

        if (showToggle) {
            const contentEl = back.querySelector('.recipe-content');
            const toggleBtns = back.querySelectorAll('.recipe-toggle-btn');

            const setActive = (target) => {
                contentEl.querySelectorAll('[data-recipe-section]').forEach((el) => {
                    el.style.display = el.dataset.recipeSection === target ? '' : 'none';
                });

                toggleBtns.forEach((btn) => {
                    btn.classList.toggle('active', btn.dataset.target === target);
                });
            };

            toggleBtns.forEach((btn) => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    setActive(btn.dataset.target);
                });
            });

            setActive('ingredients');
        }

        // Add animation for content
        back.querySelector('h2').style.opacity = 1;
        back.querySelector('div').style.opacity = 1;
        back.querySelector('button').style.opacity = 1;
        
    } catch (error) {
        console.error("Failed to fetch personalized recipe:", error);
        button.textContent = 'Try Again';
        button.disabled = false;
    }
}


// ---------------------------
// Start
// ---------------------------

showNextCard();
